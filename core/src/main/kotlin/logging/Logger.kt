package logging

import ch.qos.logback.classic.Level
import ch.qos.logback.classic.spi.ILoggingEvent
import ch.qos.logback.classic.spi.ThrowableProxy
import getPercentage
import java.lang.reflect.Field
import java.util.concurrent.ConcurrentHashMap
import kotlin.math.floor
import net.logstash.logback.marker.MapEntriesAppendingMarker
import net.logstash.logback.marker.Markers
import org.slf4j.Marker

class Logger(private val slf4jLogger: org.slf4j.Logger) {
    private val globalContext = ConcurrentHashMap<String, Any?>()
    private val contextListeners = mutableListOf<ILogContextListener>()

    fun addToContext(loggingKey: String, value: Any?) {
        globalContext[loggingKey] = value ?: ""
        updateContextListeners()
    }

    fun clearContext() {
        globalContext.clear()
        updateContextListeners()
    }

    fun addContextListener(listener: ILogContextListener) {
        contextListeners.add(listener)
    }

    private fun updateContextListeners() {
        contextListeners.forEach { it.contextUpdated(globalContext.toMap()) }
    }

    @JvmOverloads
    fun logProgress(code: String, workDone: Long, workToDo: Long, percentageToLogAt: Int = 10) {
        // Convert 1 to 0.01, 50 to 0.5, etc.
        val percentageAsDecimal = percentageToLogAt.toDouble() / 100
        val percentageOfTotal = floor(workToDo * percentageAsDecimal)
        val remainder = workDone % percentageOfTotal
        if (remainder == 0.0) {
            val percentStr = getPercentage(workDone, workToDo)
            val logStr = "Done $workDone/$workToDo ($percentStr%)"
            info(code, logStr)
        }
    }

    fun info(code: String, message: String, vararg keyValuePairs: Pair<String, Any?>) {
        log(Level.INFO, code, message, null, mapOf(*keyValuePairs))
    }

    fun warn(code: String, message: String, vararg keyValuePairs: Pair<String, Any?>) {
        log(Level.WARN, code, message, null, mapOf(*keyValuePairs))
    }

    fun error(code: String, message: String, vararg keyValuePairs: Pair<String, Any?>) {
        error(code, message, Throwable(message), keyValuePairs = keyValuePairs)
    }

    fun error(
        code: String,
        message: String,
        errorObject: Throwable = Throwable(message),
        vararg keyValuePairs: Pair<String, Any?>,
    ) {
        log(
            Level.ERROR,
            code,
            message,
            errorObject,
            mapOf(*keyValuePairs, KEY_EXCEPTION_MESSAGE to errorObject.message),
        )
    }

    fun log(
        severity: Level,
        code: String,
        message: String,
        errorObject: Throwable?,
        keyValuePairs: Map<String, Any?>,
    ) {
        val combinedKeys = globalContext + keyValuePairs + (KEY_LOGGING_CODE to code)
        val marker = combinedKeys.filterValues { it != null }.let(Markers::appendEntries)
        getLogMethod(severity).invoke(marker, message, errorObject)
    }

    private fun getLogMethod(
        severity: Level
    ): (marker: Marker, message: String, t: Throwable?) -> Unit =
        when (severity) {
            Level.ERROR -> slf4jLogger::error
            Level.WARN -> slf4jLogger::warn
            Level.INFO -> slf4jLogger::info
            Level.DEBUG -> slf4jLogger::debug
            Level.TRACE -> slf4jLogger::trace
            else -> throw RuntimeException("Unexpected log level: $severity")
        }
}

val ILoggingEvent.loggingCode: String?
    get() = findLogField(KEY_LOGGING_CODE) as? String

fun ILoggingEvent.findLogField(key: String): Any? = getLogFields()[key]

private val mapEntriesAppendingMarkerField: Field =
    MapEntriesAppendingMarker::class.java.getDeclaredField("map").apply { isAccessible = true }

fun ILoggingEvent.getLogFields(): Map<String, Any> {
    val marker = this.markerList?.firstOrNull()
    return if (marker is MapEntriesAppendingMarker) {
        mapEntriesAppendingMarkerField.get(marker) as Map<String, Any> + this.mdcPropertyMap
    } else {
        emptyMap()
    }
}

fun ILoggingEvent.errorObject(): Throwable? {
    val proxy = this.throwableProxy
    return if (proxy is ThrowableProxy) {
        proxy.throwable
    } else null
}
